def Range: class {
    def start: prop usize;
    def end: prop usize;

    def init: fn[start: usize, end: usize] -> Self {
        def result: new Self;

        result.start = start;
        result.end = end;

        return *result;
    };
};

def Slice: fn[T] -> Class {
    return class {
        def itemSize: T.SIZE;

        def ptr: prop *(T[]);
        def len: prop usize;

        def set_empty: fn[self: *Self] -> Void {
            self.ptr = null;
            self.len = usize(0);

            return;
        };

        def initFrom: fn[ptr: *T, len: usize] -> Self {
            def result: new Self;
            result.ptr = ptr;
            result.len = len;

            return *result;
        };

        def cut: fn[self: *Self, range: Range] -> Self {
            def result: new Self;
            def tmp_range: new Range = range;

            result.ptr = usize(*self.ptr) + (usize)(*tmp_range.start * itemSize);
            result.len = *tmp_range.end - *tmp_range.start;

            return *result;
        };

        def `[]`: fn[self: *Self, idx: usize] -> *T {
            return (*self.ptr)[idx];
        };
    };
};

def realloc: extern fn[] -> *Void;
def calloc: extern fn[] -> *Void;
def printf: extern fn[] -> Void;

def ArrayList: fn[T] -> Class {
    return class {
        def SliceT: Slice(T);
        def itemSize: T.SIZE;

        def items: prop SliceT;
        def capacity: prop usize;

        def init: fn[self: *Self] -> Void {
            self.capacity = usize(0);
            self.items.set_empty();

            return;
        };

        def extend: fn[self: *Self] -> Void {
            self.capacity = *self.capacity * usize(2);
            if (*self.capacity == usize(0)) 
                self.capacity = usize(1);

            self.items.ptr = realloc(*self.items.ptr, Self.itemSize * *self.capacity);

            return;
        };

        def append: fn[self: *Self, adds: T] -> Void {
            def oldSize: *self.items.len;

            self.items.len = *self.items.len + usize(1);

            if (*self.capacity < *self.items.len) {
                self.extend();
            }

            (*self.items.ptr)[oldSize] = adds;

            return;
        };        

        def pop: fn[self: *Self] -> T {
            self.items.len = *self.items.len - usize(1);

            return *((*self.items.ptr)[*self.items.len]);
        };

        def erase: fn[self: *Self, val: T] -> Void {
            def i: new usize = usize(0);
            def len: new usize = usize(0);

            while (*i < *self.items.len) {
                if (*(*self.items.ptr)[*i] != val) {
                    if (*len != *i) {
                        (*self.items.ptr)[*len] = *(*self.items.ptr)[*i];
                    }

                    len = *len + usize(1);
                }

                i = *i + usize(1);
            }

            self.items.len = *len;

            return;
        };

        def contains: fn[self: *Self, val: T] -> Bool {
            def i: new usize = usize(0);
            def result: new Bool = Bool(false);

            while (*i < *self.items.len) {
                if (*(*self.items.ptr)[*i] == val)
                    result = Bool(true);

                i = *i + usize(1);
            }

            return *result;
        };
        
        def `[]`: fn[self: *Self, idx: usize] -> *T {
            return self.items[idx];
        };
    };
};

def Closure: fn[I, P, O, Func] -> Class {
    return class {
        def I: I;
        def P: P;
        def O: O;

        def data: prop I;

        def init: fn[inside: I] -> Self {
            def result: new Self;

            result.data = inside;

            return result;
        };

        def run: fn[self: *Self, params: Self.P] -> Self.O {
            return Func(*self.data, params);
        };
    };
};

def Interface: fn[V, D] -> Class {
    def Result: class {
        def Data: D;

        def data: prop D;
        def self: prop *Void;

        def VTable: class {
            def LIST: V;
        };
    };

    for FnEntry in (V) {
        @ADD_DEF(Result.VTable, FnEntry[0], prop *fn[func: *Void, data: *Result.Data] -> FnEntry[1]);
        def funcImpl: fn[self: *Result] -> FnEntry[1] {
            return (*@GET_PROP(self.vtable, FnEntry[0]))(*self.self, self.data);
        };

        @ADD_DEF(Result, FnEntry[0], @SET_NAME(funcImpl, FnEntry[0]));
    }

    @ADD_DEF(Result, "vtable", prop Result.VTable);

    def initImpl: fn[T: Type, instance: *Void] -> Result {
        def result: new Result;
        
        result.self = instance;
        result.data = Result.Data.init();

        for FnEntry in (Result.VTable.LIST) {
            def entryName: FnEntry[0];

            @GET_PROP(result.vtable, entryName) = @GET_PROP(T, entryName);
        }

        return *result;
    };

    @ADD_DEF(Result, "init", initImpl);

    return Result;
};

def Optional: fn[T] -> Class {
    return class {
        def BASE_TYPE: T;
        def val: prop BASE_TYPE;
        def has: prop Bool;

        def none: fn[] -> Self {
            def result: new Self;
            result.has = Bool(false);

            return *result;
        };

        def some: fn[base: *BASE_TYPE] -> Self {
            def result: new Self;
            result.val = base;
            result.has = Bool(true);

            return *result;
        };
    
        def is_none: fn[self: *Self] -> Bool {
            return *self.has == Bool(false);
        };
        
        def is_some: fn[self: *Self] -> Bool {
            return *self.has == Bool(true);
        };
    };
};

def Result: fn[T, E] -> Class {
    return class {
        def isErr: prop Bool;
        def valv: prop T;
        def errv: prop E;
        
        def ok: fn[base: T] -> Self {
            def result: new Self;
            result.isErr = Bool(false);
            result.val = base;

            return *result;
        };

        def err: fn[base: E] -> Self {
            def result: new Self;
            result.isErr = Bool(true);
            result.err = base;

            return *result;
        };
    };
};

def String: class {
    def base: prop ArrayList(u8);  
    
    def init: fn[] -> Self {
        def result: new Self;
        result.base.init();

        return *result;
    };

    def from: fn[s: *u8[]] -> Self {
        def result: new Self;
        result.base.init();

        def st: new *u8[] = s;

        while (*(*st)[usize(0)] != u8(0)) {
            result.base.append(*(*st)[usize(0)]);

            st = usize(*st) + usize(1);
        }

        return *result;
    };

    def append: fn[self: *Self, s: *u8[]] -> Void {
        def st: new *u8[] = s;

        while (*(*st)[usize(0)] != u8(0)) {
            self.base.append(*(*st)[usize(0)]);

            st = usize(*st) + usize(1);
        }

        return *self;
    };

    def println: fn[self: *Self] -> Void {
        printf("%.*s\n", *self.base.items.len, *self.base.items.ptr);

        return;
    };

    def len: fn[self: *Self] -> usize {
        return *self.base.items.len;
    };

    def `[]`: fn[self: *Self, idx: usize] -> *u8 {
        return self.base[idx];
    };
};
